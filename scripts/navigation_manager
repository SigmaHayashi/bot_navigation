#!/usr/bin/env python
# -*- coding:utf-8 -*-

import rospy

from move_base_msgs.msg import MoveBaseAction, MoveBaseActionGoal, MoveBaseGoal
import actionlib
from geometry_msgs.msg import Vector3, Quaternion
import tf
import math

from actionlib_msgs.msg import GoalID, GoalStatusArray

from lawnmower.msg import nav_manager_command, nav_manager_status


class NavigationManager():
    def __init__(self):
        rospy.loginfo("Init NavigationManager")

        self.goal_count = 0
        self.goal_list = []

        self.recent_goal_id = ''
        
        self.status = 0
        self.status_backup = 0
        # 0 : stop
        # 1 : pause
        # 2 : moving
        # 3 : moving (rviz)

        # 一度ゴール方向を向く（その場旋回）（とりあえず保留）（やっぱり使わない）
        # その後，動き出す

        self.action_client = actionlib.SimpleActionClient('move_base', MoveBaseAction)
        while not self.action_client.wait_for_server(rospy.Duration.from_sec(3.0)):
            rospy.loginfo('Waiting for Action Server...')
        rospy.loginfo('Connected to Action Server')

        #self.pub_cancel = rospy.Publisher('move_base/cancel', GoalID, queue_size=1)

        self.pub_status = rospy.Publisher('nav_manager/status', nav_manager_status, queue_size=1)

        rospy.Subscriber('nav_manager/command', nav_manager_command, self.callback_command, queue_size=1)

        rospy.Subscriber('move_base/status', GoalStatusArray, self.callback_move_base_status, queue_size=1)
        rospy.Subscriber('move_base/goal', MoveBaseActionGoal, self.callback_move_base_goal, queue_size=1)


    def callback_command(self, data):
        rospy.loginfo('Received: /nav_manager/command')

        if data.command == 'start':
            rospy.loginfo('command: start')
            self.goal_list = []
            i = 0
            for pos in data.position_list:
                self.goal_list.append(Vector3(pos.x, pos.y, 0.0))
                rospy.loginfo('Received Goal [{}]: (x={:.2f}, y={:.2f})'.format(i, pos.x, pos.y))
                i = i + 1

            self.goal_count = 0
            self.send_goal(self.goal_count)
            self.action_client.wait_for_result(rospy.Duration.from_sec(0.5))

            self.status = 2

        elif data.command == 'stop':
            rospy.loginfo('command: stop')

            #msg = GoalID()
            #msg.stamp = rospy.Time.now()
            #msg.id = ''
            #self.pub_cancel.publish(msg)
            self.action_client.cancel_all_goals()

            self.goal_list = []
            self.goal_count = 0
            self.status = 0

        elif data.command == 'pause':
            rospy.loginfo('command: pause')

            if self.status == 2 or self.status == 3: # 動いているときだけ
                #msg = GoalID()
                #msg.stamp = rospy.Time.now()
                #msg.id = ''
                #self.pub_cancel.publish(msg)
                self.action_client.cancel_all_goals()

                self.status_backup = self.status
                self.status = 1

        elif data.command == 'resume':
            rospy.loginfo('command: resume')

            if self.status == 1: # ポーズ中だけ
                self.send_goal(self.goal_count)
                self.status = self.status_backup

        else:
            rospy.logwarn('command not defined: ' + data.command)


    def send_goal(self, count):
        goal = MoveBaseGoal()
        goal.target_pose.header.stamp = rospy.Time.now()
        goal.target_pose.header.frame_id = 'map'

        goal.target_pose.pose.position = self.goal_list[count]

        #qua = tf.transformations.quaternion_from_euler(0.0, 0.0, 0.0)
        if count == len(self.goal_list) - 1:
            yaw = 0.0
        else:
            yaw = math.atan2(self.goal_list[count+1].y - self.goal_list[count].y, self.goal_list[count+1].x - self.goal_list[count].x)
        qua = tf.transformations.quaternion_from_euler(0.0, 0.0, yaw)
        goal.target_pose.pose.orientation = Quaternion(x=qua[0], y=qua[1], z=qua[2], w=qua[3])

        self.action_client.send_goal(goal)
        #self.action_client.wait_for_result(rospy.Duration.from_sec(5.0))
        #self.action_client.wait_for_result(rospy.Duration.from_sec(0.5))

        #print("Goal State: " + str(self.action_client.get_state()))

        rospy.loginfo('Send Goal [{}]: (x={:.2f}, y={:.2f}, yaw={:.2f})'.format(count, self.goal_list[count].x, self.goal_list[count].y, yaw))
        #self.last_goal_published = goal.target_pose.header.stamp


    def callback_move_base_status(self, data):
        #rospy.loginfo('Received: /move_base/status')
        #if len(data.status_list) > 0 and (self.status == 2 or self.status == 3):
        if len(data.status_list) > 0:
            if self.status == 2:
                for status in data.status_list:
                    if status.goal_id.id == self.recent_goal_id and status.status == 3:
                        rospy.loginfo('Reached Goal')
                        
                        if self.goal_count == len(self.goal_list) - 1:
                            self.goal_count = 0
                            self.status = 0
                            rospy.loginfo('Finish')
                        else:
                            self.goal_count = self.goal_count + 1
                            self.send_goal(self.goal_count)
                            
                        break

            elif self.status == 3:
                #stamp_list = []
                stamp_max = 0
                for status in data.status_list:
                    #stamp_list.append(float(status.goal_id.id.split('-')[2]))
                    stamp = float(status.goal_id.id.split('-')[2])
                    if stamp_max < stamp:
                        stamp_max = stamp
                        #target_id = status.goal_id.id
                        stamp_max_status = status.status
                #print(stamp_list)
                if stamp_max_status == 3:
                    rospy.loginfo('Reached Goal')

                    self.status = 0
                    rospy.loginfo('Finish')
    
    
    def callback_move_base_goal(self, data):
        self.recent_goal_id = data.goal_id.id

        if data.goal_id.id == '':
            q = data.goal.target_pose.pose.orientation
            goal = Vector3(
                data.goal.target_pose.pose.position.x,
                data.goal.target_pose.pose.position.y,
                tf.transformations.euler_from_quaternion((q.x, q.y, q.z, q.w))[2])
            self.goal_list = []
            self.goal_list.append(goal)
            self.goal_count = 0
            self.status = 3


    def publish_status(self):
        msg = nav_manager_status()
        msg.header.stamp = rospy.Time.now()
        
        if self.status == 0:
            msg.status = 'stop'
        elif self.status == 1:
            msg.status = 'pause'
        elif self.status == 2 or self.status == 3:
            msg.status = 'run'

        self.pub_status.publish(msg)


if __name__ == "__main__":
    rospy.init_node('navigation_manager', anonymous=True)
    rospy.loginfo("NavigationManager node Start")

    rate = rospy.Rate(10)

    try:
        nav_manager = NavigationManager()
        #rospy.spin()
        while not rospy.is_shutdown():
            nav_manager.publish_status()
            rate.sleep()

    except rospy.ROSInterruptException:
        pass
